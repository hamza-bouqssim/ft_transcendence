generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Status {
  PENDING
  ACCEPTED
  BLOCKED
}

enum Result {
  WIN
  LOSS
  UNPROCESSED
}

enum EventType {
  UNPROCESSED
  FINAL
}

model User {
  id String @id @default(uuid())
  username String 
  email String @unique
  password String
  display_name String @unique
  avatar_url String
  two_factor_auth String
  two_factor_secret_key String
  rank String
  friend Friend[] @relation("UserToFriend")
  friends Friend[] @relation("Friend")
  senderOfChatParticipents ChatParticipents[] @relation("sender")
  recipientOfChatParticipents ChatParticipents[] @relation("recipient")
  senderOfmessage Message[] @relation("senderMessage")
  RecipientOfmessage Message[] @relation("recipientMessage")
  notifications Notification[]
  player1 Pong_match[] @relation("player1")
  player2 Pong_match[] @relation("player2")
  Member  Member[]
  blockingUsers       BlockUser[] @relation("blockingUsers")
  blockedByUsers      BlockUser[] @relation("blockedByUsers")
  messageRome  MessageRome[]

}

model BlockUser {
  id             String    @id @default(uuid())
  userId         String
  blockedUserId  String
  createdAt      DateTime
  blockingUsers   User      @relation("blockingUsers", fields: [userId], references: [id])
  blockedByUsers    User      @relation("blockedByUsers", fields: [blockedUserId], references: [id])
}


model Friend {
  id         String   @id @default(uuid())
  user_id    String
  friend_id  String
  status     Status   @default(PENDING)
  created_at DateTime
  user       User     @relation("UserToFriend", fields: [user_id], references: [id])
  friends    User     @relation("Friend", fields: [friend_id], references: [id])
}

model ChatParticipents {
  id          String      @id @default(uuid())
  sender      User     @relation("sender", fields: [senderId], references: [id])
  senderId    String
  recipient   User     @relation("recipient", fields: [recipientId], references: [id])
  recipientId String
  messages    Message[] @relation("participentsMessages")
  lastMessage Message?   @relation("lastMessageSent", fields: [lastMessageId], references: [id])
  lastMessageId String?
}

model Message {
  id String @id @default(uuid())
  content String?
  sender User @relation("senderMessage", fields: [senderId], references: [id])
  senderId String
  recipient User @relation("recipientMessage", fields: [recipientId], references: [id])
  recipientId String
  participents ChatParticipents @relation("participentsMessages", fields: [participentsId], references: [id])
  participentsId String
  lastMessageFor ChatParticipents[] @relation("lastMessageSent")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id      String @id @default(uuid())
  user_id String
  content String
  user    User   @relation(fields: [user_id], references: [id])
}

model StateGame {
  id            String @id @default(uuid())
  user_id       String @unique
  win           Int    @default(0)
  lose          Int    @default(0)
  level         Float  @default(1.0)
  numberOfMatch Int    @default(0)
  rank          Int    @default(-1)
  user          User   @relation(fields: [user_id], references: [id])
}
// inprogress
model Achievement {
  id      String @id @default(uuid())
  user_id String 
  content String
  type    String
  picture String
  win     Int
  lose    Int
  level   Float
  user    User   @relation(fields: [user_id], references: [id])
}

model Pong_match {
  id           String          @id @default(uuid())
  player1_id   String          
  player2_id   String          
  created_at   DateTime        @default(now())
  updated_at   DateTime        @updatedAt
  event        EventType       @default(UNPROCESSED)
  playerOne    User            @relation("player1", fields: [player1_id], references: [id])
  playerTwo    User            @relation("player2", fields: [player2_id], references: [id])
  matchHistory Match_History[]
}

model Match_History {
  id              String     @id @default(uuid())
  playerOne       String
  playerTwo       String
  playerOne_score Int
  playerTwo_score Int
  matchId         String
  playerone       User       @relation("playerOne", fields: [playerOne], references: [id])
  playertwo       User       @relation("playerTow", fields: [playerTwo], references: [id])
  match           Pong_match @relation(fields: [matchId], references: [id])
}

model Queue {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
}

model ChatRoom {
  id        String @id @default(uuid())
  name      String    @unique
  Privacy   String   
  password  String?
  picture   String?  @default("https://images.squarespace-cdn.com/content/v1/5f60d7057b9b7d7609ef628f/1603219780222-V253F1WLHBH8HNHXIFUX/group.png")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  members   Member[]
  messageRome  MessageRome[]
}

model Member {
  id          String @id @default(uuid())
  user_id     String
  chatRoomId  String
  isAdmin     Boolean
  user        User        @relation(fields: [user_id], references: [id])
  chatRoom    ChatRoom    @relation(fields: [chatRoomId], references: [id])
}

model MessageRome{
  id          String @id @default(uuid())
  content     String
  chatRoomId  String
  senderId    String
  createdAt   DateTime @default(now())
  user        User        @relation(fields: [senderId], references: [id])
  chatRoom    ChatRoom    @relation(fields: [chatRoomId], references: [id])

}


model Session {
  id        String   @id @default(uuid())
  sid       String   @unique
  data      String
  expiresAt DateTime
}
